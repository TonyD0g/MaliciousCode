# 随记

#### 基础知识/注意事项

```md
1.没说就是16进制,如01H表示为01

2.表示值:
如果 01H 的值为P时,则表示为 (01)=P	

3.小端存储
比如内存中表示为 00 10,则实际上表示为1000

4.如果是32位的系统，则一个字Word是4个字节，如果是64位，则一个字Word是8个字节                                                                                                                5.**（图片中标红的为重要部分,其他无需关注）**          

6.减法的问题：因为是从0开始计数的，所以 
被减数 - 减数 = 商	
这个式子中，被减数不用动,减数+1	如 被减数为80,减数为3f,式子为 80 - 40 = 40 (h)
```



判断是否是PE文件:

```md
查看文件的二进制，如果开头(01)=4D,(02)=5A，接着来到(3C)的位置，查看值，
如果值等于E8，则看(E9)=50,(EA)=45
则说明是PE文件。
```

PE结构总览：https://www.cnblogs.com/doubleconquer/p/15106239.html#_label1



###  查看windows api所在的位置

使用DTDebug 工具，点击蓝色的"E"按钮，找到api所在的dll点击,然后在打开的新窗口按ctrl + n

**每次重启电脑后，api基址都会改变！**





# PE头



PE文件的整体结构

(这些结构体你都可以在`Microsoft Visual Studio\VC98\Include\WINNT.H`头文件中看见。)

![1](Photo\1.png)



各部分大小值:

![1](Photo\2.png)





IMAGE_FILE_HEADEER		  	称之为标准的PE文件头

IMAGE_OPTIONAL_HEADER 	称之为扩展的PE文件头



SizeOfHeaders	:	即DOS部分 + PE文件头 + 节表 的长度相加 后，再进行文件对齐后的长度

什么是文件对齐：

比如基址为200，DOS部分 + PE文件头 + 节表 的长度相加 后 等于 302，

则SizeOfHeaders	为 400，多出来的部分补零



两个状态的文件对齐(在`扩展PE头结构体里`)：

1.磁盘状态下的文件对齐：基址为200

2.内存状态下的文件对齐：基址为1000



Dos stub部分可以随意更改,删除,不影响PE文件的运行

节数据的定义是由`节表`决定的。节的个数是由`标准PE头中`的`NumberOfSecions`决定



### 标准的PE文件头



![1](Photo\3.png)



### 扩展的PE文件头

**(32位和64位的不一样，64位的加了一些东西,下面这个图是32位的)**

![1](Photo\4.png)





### 扩展PE头

1.`ImageBase` ：内存中放置PE文件的起始位置

2.`AddressOfEntryPoint` :	相当于C中的main,即	**程序入口点**

3.`ImageBase` + `AddressOfEntryPoint` = 程序运行的位置

4.`SizeOfImage` :	内存展开后的总大小	(依旧是文件对齐后的长度)

5.头和头是紧密相连的，内存和磁盘中的文件对齐的差别在于后面填充的0的数量

6.DllCharacteristics 选项的具体说明:

![1](Photo\5.png)



7.扩展PE头的大小是可以进行更改的，具体看标准PE头的`SizeOfOptionalHeader`参数



### RVA和FOA的转换

1.如果一个全局变量有初始值，则PE文件中一定有他的位置，反之是加载到内存中系统自动给了全局变量0值

2.`RVA`：相对虚拟地址 ,	`FOA` : 文件偏移地址

3.`VirualAddress` 在内存中的位置

4.`RVA` 和 `FOA` 转换的前提：磁盘对齐(FileAlignment)和内存对齐(SectionAlignment)的基址不一样，如果磁盘对齐和内存对齐的基址一样的话，直接代入另外一个就可以求解

5.**转换的公式：**

(`PointerToRawData`是节表结构的属性)

![1](Photo\7.png)





### PE节表

1.节表结构说明:

![1](Photo\6.png)

# 相关技术

### 导出表

1.一个可执行程序并不是只由一个PE文件组成,因为有dll文件的参与

2.`exe`文件通常不提供导出表(即不提供函数给别人用，但不代表它不能提供导出表)

3.导出表存在于扩展PE头中的最后一个成员中：结构体数组

​	结构体数组有16个，导出表是第一个,一个结构体数组为8个字节。16个结构体数组即UE编辑器中的8行



```md
# 结构体数组成员结构：

struct xxx(
0x00 DWORD VirtualAddress;	# RVA地址
0x04 DWORD Size;			# 大小
);
```

4. 先通过结构体数组成员结构找到所对应的RVA地址，根据导出表结构（即下图）的大小进行选取，即40个字节

为什么 `结构体数组成员结构`中的Size和 `导出表结构`40个字节大小不符合呢：因为 `结构体数组成员结构`中的Size 是包含了`导出表结构`中的指针所指向的大小.



![1](Photo\8.png)



5.`NumberOfFunctions` 和 `NumberOfNames` 可以不一样，因为有些`导出函数`用名字表示，有些是直接用序号表示

6.`AddressOfFunctions(函数地址表)` ,`AddressOfNames(函数名称表)` ,`AddressOfNameOrdinals(序号表)` 记录的都是地址

根据地址去找寻，就是成员所对应的值,如 `NumberOfNames`的值为3, `AddressOfNames(函数名称表)`的值为5acc , 则来到 5acc 的位置，往后12(即3*4) 个字节都是`AddressOfNames(函数名称表)`的值

7.`AddressOfNames(函数名称表)` 的值是按照拼音排序的

8.`AddressOfNameOrdinals(序号表)`的个数和`AddressOfNames(函数名称表)`的个数一致

9.`AddressOfNameOrdinals(序号表)`的每个值是2个字节的，不像`AddressOfFunctions` ,`AddressOfNames` 的每个值都是4个字节的

**10.两种查导出函数的方法：**

​	a. 使用名称查找：

​		 先输入要查找的导出函数名称，在`AddressOfNames(函数名称表)`中进行查找，比如查找到了是下标为第`0`个成员，则来到`AddressOfNameOrdinals(序号表)`中的下标为第`0`个的位置并查看它的值,比如说是`4`，则再来到`函数地址表`中的下标为第`4`个的位置并查看它的值,这个值就是我们所要查找的`导出函数的地址`



​	b. 使用序号查找

​		序号 - `Base` = 实际的下标

​		直接用下标查看`AddressOfFunctions(函数地址表)`即可

### 导入表

![1](Photo\9.png)

1.导出表存在于扩展PE头中的最后一个成员中：结构体数组

结构体数组有16个，导入表是第2个,一个结构体数组为8个字节。16个结构体数组即UE编辑器中的8行

2.



3.连续20个0为导入表结束

![1](Photo\15.png)

![1](Photo\11.png)

4.IMAGE_THUNK_DATA 对应的表为 _IMAGE_THUNK_DATA32

有用的部分为`Ordinal`和`AddressOfData` ，联合体为4个字节，连续4个字节为0则结束



![1](Photo\16.png)



5.`_IMAGE_IMPORT_BY_NAME` 中Hint 不是导出符号，是`函数地址表`的索引

Name[1] 只记录一个字符,一直往后数直到碰到0

![1](Photo\10.png)



### 确认函数地址

1.间接Call:

自行编写的代码调用了API ，此时的汇编代码: **call 间接地址**,去访问间接地址中的内容才是真正的API地址

2.为什么有两个表**(IAT,INT)**

为了相互有个参照物，如IAT中某个函数地址不正确，我们可以查找IAT获取名字,然后再GetProcAddress 即可获取该函数的正确地址



### 重定位表

![1](Photo\14.png)



1.为什么需要重定位表

​	A,B两个DLL，加载的基址都为1000000 就会覆盖，所以有一个必须去加载别的基址，比如是A占了1000000,B只能去占了2000000 ，但B中的某个全局变量依旧以基址为 1000000 开头的话就会出问题（因为这个变量未进行相关偏移）

​	所以需要一个表去记录这些没偏移的变量，然后对它们进行相对应的更改，这个表就是**重定位表**

2.重定位表所在的位置：

​	**扩展PE头的最后一个成员->第6个**

3._IMAGE_BASE_RELOCATION(`重定位块`)中的`SizeOfBlock` 有多大，那么所代表的这个重定位块就有多大的字节

重定位表是由一堆小重定位表组成的:

![1](Photo\12.png)

4.什么时候结束:	连续8个0则为结束

5.为什么重定位表要这么设计：如801000 ~ 809999 要修正偏移，需要4 * 8999 个字节，但如果把相同部分抽离出来，如抽了800000作为基址，那只需要 3 + 2 * 8999 个字节

6.内存是以4KB作为一个物理页，有120个物理页就有120个重定位表

7.![1](Photo\13.png)

为什么：因为需要找偏移，2^12 = 4KB,而一个物理页为4KB，一个字节为8位是显然不够12位的，所以需要2个字节。

**（真正使用的是12位，当多出来的高4位为3时，**

**`VirtualAddress + (2个字节 - 高4位) = 最后修复的偏移`. **

**否则这2个字节里面的值无所谓，只是用来内存对齐用的）**



### 新增节

1.壳的原理：加密完，会新增一些节

**2.新增节的步骤：(S为自定义添加的大小)**

​	(1) 判断是否有足够的空间，可以添加一个节表

​	(2) 在节表中新增一个成员

​	(3) 修改PE头中节的数量 = 节 + 1

​	(4) sizeOfImage  = sizeOfImage + S (扩展PE头中)

​	(5) 在原有数据的最后,新增一个节的数据(内存对齐的整数倍)

​		 即修改 原本最后一个节的 VirualSize 和 SizeOfRawSize 改为一样的大小

​		 新增加节的VirtualAddress = 上一个节内存对齐后的大小+上一个节.VirtualAddress

​	(6) 修正新增节表的属性

​	(7) 先删除第一个节前面的40个字节（因为前面新增加了一个节表，数据全部往后推移了40个字节）



### 扩大节

1.为什么要扩大节：

​	我们可以在任意空白区添加自己的代码，但如果添加的代码比较多，空白区不够多的情况下

2.最好只`去扩大最后一个节`，避免使得其他节都往后移动很麻烦

3.**扩大节的步骤:**

​	(1) 分配一块新的空间，大小为S

​	(2) `IMAGE_SIZEOF_SHORT_NAME` 节表结构体中：

​		(`SizeOfRawData` 和 `VirtualSize`中，谁大选谁)

​		 将**最后一个节**的`SizeOfRawData`和`VirtualSize`改成N

​		 N = (`SizeOfRawData` 或者 `VirtualSize` 内存对齐后的值) + S

​		 修改 `SizeOfImage` 大小  = 原先的先对齐，再加上S

​		   **(扩展PE头的结构体中)**

​		（SizeOfImage 显示的是已经展开后的大小）

​    (3)UE来到文件末尾，右键插入S空间

​	(4) 如果所选择的节并没有可执行权限，就需要修改**IMAGE_SIZEOF_SHORT_NAME 节表结构体**中的 **Characteristics**属性

### 添加空白代码(xp 系统下)

如：我们想要添加一个`MessageBox`到某一个PE文件中去,一个最简单的`MessageBox`的汇编代码（可以先用C编写，再查看反汇编代码)：

(**?? 的位置是待填入的地址**)

```MD
6A 00 6A 00 6A 00 6A 00 E8 ?? ?? ?? ?? E9 ?? ?? ?? ??
```



1.我们想要执行我们添加的代码，就先把入口点改为我们的代码，执行完后再跳回原来的入口点

2.硬编码：`E8` 是 `call` 指令，`E9`是 `jmp` 指令	`6A `是 `push` 指令

3.实际填写到PE的地址	= 我要跳转的地址 - `xx` 指令当前的地址(**加上ImageBase**) - 5







